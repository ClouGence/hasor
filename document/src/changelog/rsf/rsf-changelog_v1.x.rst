--------------------
Release RSF v1.x
--------------------
.. CAUTION::
    RSF 在 3.2.1 回归 Hasor 之后，更新日志将会跟随 Hasor。


RSF v1.3.1 (2017-02-23)
------------------------------------
**新增**
    - 新增别名功能，Hprose会利用通过别名来定位服务。目前注册中心不会管理别名。
**修复**
    - 修复 LocalPref 在寻找 provider Method 时用错对象导致找不到方法的异常。


RSF v1.3.0 (2017-02-17)
------------------------------------
**新增**
    - RSF项目拆分成 framework 和 registry 两个部分。
    - framework 项目是 RSF 的核心实现了 P2P 模式下的 RPC 调用以及流量控路由等功能。
    - registry 项目是 RSF 的独立的注册中心实现，包括 RSF 注册中心客户端，注册中心服务端。
**改进**
    - 当服务方法被调用期间发生错误时，回传的Error信息中携带类名和异常信息。
    - Hasor使用 3.1.1 版本
    - 明确 Hprose 协议上不支持如下特征“批量调用、引用参数”如遇上述类型的请求直接返回异常。
    - Netty 都使用堆内内存，以后在优化成堆外内存。
    - 各种Utils自己拥有一份，降低和Hasor的工具耦合性。
**修复**
    - 修复一些情况下当请求没有参数时，RSF报空指针的异常。
    - fix Hprose 在解析请求参数中的基础类型时发生序列化异常的问题。
    - fix 当启用了多协议情况下，服务提供者注册到center时，消费者收到了不该接收到的其它协议地址。


RSF v1.2.0 (2017-01-29)
------------------------------------
**新增**
    - 加入多协议支持，第一个被支持的协议是 Hprose RPC
    - 夸语言，通过 Hprose RSF可以支持多达 25 种编程语言
    - 自定义 RPC 协议支持，除了 RSF、Hprose 之外您可以制定自己的 RPC 传输协议。
**改进**
    - 使用 Hasor 最新的ApiBinder扩展机制提供 RsfApiBinder，受此影响 RsfModule 不在是必需品。
    - RsfPlugin 接口不在需要。
    - RsfCenterEvent 枚举形式改为字符串形式。
    - 兼容 Spring 4.x，和 Spring Boot。
    - 简化设计，取消RSF握手机制、取消 A->B,B->A 双向共享连接机制，保留单向方向请求连接复用机制。


RSF v1.1.0 (2016-12-01)
------------------------------------
**新增**
    - RsfApiBinder 新增 converToProvider 方法方便 RSF 服务注册到 Hasor。这样 Hasor 就可以依赖注入一个 RSF 服务。
    - RsfPublisher 接口可以通过 AppContext 直接拿到了，不需要通过 RsContext 接口间接获取。极大的方便了服务注册。
    - RsfUpdater 接口可以查询服务的提供者地址列表。
    - 新增 Telent命令， info 用来查看服务器配置信息、detail 用来查看服务的详细信息。
    - 新增 RSF_GATEWAY_IP、RSF_GATEWAY_PORT 两个参数配置，通过配置该参数将允许 RSF 通过端口映射工作在内网环境中。
**改进**
    - telnet 的交互信息可以被单独打印到一个日志文件中，另外 telnet 的输出日志更详细了。
    - RsfCenter 的 client 部分进行重构优化，服务数据和RSF公用一套。降低了设计复杂度，减少了实现代码。
    - Telent命令 list 只能用来显示服务列表，不在提供服务信息详情的显示。相关功能交给 detail 指令提供。
**修复**
    - Spring 插件在配置 RSF Bean 时始终使用默认 GNV 数据覆盖用户配置文件。
    - 修复在 tomcat 容器下 DiskCacheAddressPool 在执行地址本缓存时，爆Class找不到的异常。原因是创建的线程 ClassLoader 使用不当。


RSF v1.0.1 (2016-11-08)
------------------------------------
**新增**
    - Spring 集成。
**修复**
    - 修复因 ClassLoader 不同而导致的 shutdown 过程中各种异常的问题。
    - Fix ApiBinder 在注册 Provider 时部分方法无法将 Provider 识别为 Customer 的情况。


RSF v1.0.0 (2016-10-27)
------------------------------------
**特色功能**
    - 支持服务热插拔：支持服务动态发布、动态卸载
    - 支持服务分组：支持服务分组、分版本
    - 支持多种方式调用：同步、异步、回调、接口代理
    - 支持多种模式调用：RPC模式调用、Message模式调用
        RPC     模式: 远程调用会等待并返回执行结果。适用于一般方法。遇到耗时方法会有调用超时风险
        Message 模式: 远程调用当作消息投递到远程机器，不会产生等待，可以看作是一个简单的 MQ。适合于繁重的耗时方法
    - 支持点对点调用。RSF的远程调用可以点对点定向调用，也可以集群大规模部署集中提供同一个服务
    - 支持虚拟机房。通过配置虚拟机房策略可以降低跨机房远程调用
    - 支持泛化调用。简单的理解，泛化调用就是不依赖二方包，通过传入方法名，方法签名和参数值，就可以调用服务
    - 支持隐式传参。可以理解隐式传参的含义为，不需要在接口上明确声明参数。在发起调用的时传递到远端
    - 内置 Telnet 控制台，可以命令行方式直接管理机器
    - 支持 offline/online 动作。
**扩展性**
    - 支持第三方集成，可以独立使用,也可以和 Spring、Jfinal等第三方框架整合使用
    - 支持拦截器RsfFilter，开发者可以通过扩展 Filter 实现更多需求
    - 支持自定义序列化。默认使用内置 Hessian 4.0.7 序列化库
    - 支持Telnet控制台自定义指令。通过扩展控制台指令，可以发挥更大想象空间
**稳定性(参数可配置)**
    - 最大发并发请求数配置（默认:200）
    - 最大发起请求超限制策略设置: A-等待1秒重试、B-抛异常（默认:B-抛异常）
    - Netty线程数配置（默认: 监听请求线程数: 1，IO线程数: 8）
    - 提供者调用队列容量配置（默认: 队列容量: 4096）
    - Work线程数配置（默认: 处理调用线程数: 4）
    - 请求超时设置。支持服务提供者，服务订阅者独立配置各自的超时参数（默认 6000毫秒）
    - 双向通信。RSF会合理利用Socket连接，双向通信是指当A机器发起远程调用请求之后，RSF会建立长连接。
        -- 如果B机器有调用A机器的需求则直接使用这个连接不会重新创建新的连接，双向通信会大量降低集群间的连接数。
    - 支持优雅停机。应用停机，Center会自动通知整个集群。即便所有 Center 离线，RSF也会正确处理失效地址。
**健壮性**
    - 每小时地址本动态备份。当所有注册中心离线，即便在没有注册中心的情况下应用程序重启，也不会导致服务找不到提供者的情况。
    - 当某个地址失效之后，RSF会冻结一段时间，在这段时间内不会有请求发往这个地址。
    - 支持请求、响应分别使用不同序列化规则。
**可维护性**
    - 支持QoS流量控制。流控可以精确到：接口、方法、地址。
    - 支持动态路由脚本。路由可以精确到：接口、方法、参数。
    - 通过路由脚本可以轻松实现接口灰度发布。
**安全性**
    - 支持发布服务授权。
    - 支持服务订阅授权。
    - 支持匿名应用。
